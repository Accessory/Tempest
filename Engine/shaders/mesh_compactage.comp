#version 450

#extension GL_EXT_control_flow_attributes:enable

layout(local_size_x = 64) in;

struct IndirectCmd {
  uint    indexCount;
  uint    instanceCount;
  uint    firstIndex;    // prefix sum
  int     vertexOffset;  // can be abused to offset into var_buffer
  uint    firstInstance; // caps: should be zero

  uint    self;
  uint    vboOffset;
  uint    padd1;
  };

layout(binding = 0, std430) buffer EngineInternal0 {
  IndirectCmd cmd[];
  } indirect;

layout(binding = 1, std430) readonly buffer EngineInternal1 {
  uint    varGrow;
  uint    grow;
  uint    dispatchX;
  uint    dispatchY;
  uint    dispatchZ;
  uint    desc[];
  } mesh;

layout(binding = 2, std430) readonly buffer EngineInternal2 {
  uint    heap[];
  } var;

layout(binding = 3, std430) buffer EngineInternal3 {
  uint    heap[];
  } compacted;

void main() {
  uint mestId     = gl_GlobalInvocationID.x*3;

  [[branch]]
  if(gl_GlobalInvocationID.x>=mesh.grow)
    return;

  uint self       = mesh.desc[mestId+0];
  uint indPtr     = mesh.desc[mestId+1];
  uint desc       = mesh.desc[mestId+2];

  uint indSize    = (desc       ) & 0x3FF;
  uint maxVertex  = (desc >> 10 ) & 0xFF;
  uint varSize    = (desc >> 18u);
  uint vMem       = maxVertex*varSize;
  uint vertPtr    = indPtr + indSize;

  uint firstIndex = indirect.cmd[self].firstIndex;
  uint iboOffset  = atomicAdd(indirect.cmd[self].indexCount, indSize) + firstIndex;
  uint vboOffset  = atomicAdd(indirect.cmd[self].vboOffset,  vMem);

  [[loop]]
  for(uint i=0; i<vMem; ++i) {
    compacted.heap[vboOffset+i] = var.heap[vertPtr+i];
    }

  [[loop]]
  for(uint i=0; i<indSize; ++i) {
    compacted.heap[iboOffset+i] = vboOffset + var.heap[indPtr+i]*varSize;
    }
  }
